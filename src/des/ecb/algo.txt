On commence par prendre notre bloc et on va lui mettre une permutation initiale (changer lordre des bits selon la table) :

static const uint8_t IP[64] = {
	58, 50, 42, 34, 26, 18, 10,  2,
	60, 52, 44, 36, 28, 20, 12,  4,
	62, 54, 46, 38, 30, 22, 14,  6,
	64, 56, 48, 40, 32, 24, 16,  8,
	57, 49, 41, 33, 25, 17,  9,  1,
	59, 51, 43, 35, 27, 19, 11,  3,
	61, 53, 45, 37, 29, 21, 13,  5,
	63, 55, 47, 39, 31, 23, 15,  7
};

Gardons ce nouveau binaire dans une variable appelé _cypher

Avant d'encrypter _cyper, on va creer des subkeys (16) a partir de la clés donnée en amont (et en aval)

On va donc faire un des_key_schedule :

Il faut quon transforme notre cle de 64 bits en 56 bits
Cest grace a PC1 -> fait un choix des bits a garder parmis les 64 :

// Tableau de permutation PC-1 : 64 bits -> 56 bits
static const int PC1[56] = {
	57, 49, 41, 33, 25, 17, 9,
	1, 58, 50, 42, 34, 26, 18,
	10, 2, 59, 51, 43, 35, 27,
	19, 11, 3, 60, 52, 44, 36,
	63, 55, 47, 39, 31, 23, 15,
	7, 62, 54, 46, 38, 30, 22,
	14, 6, 61, 53, 45, 37, 29,
	21, 13, 5, 28, 20, 12, 4
};

Puis on divise notre cle de 56 bits en 2 cles de 28 : C0 et D0

Sur ces deux nouvelles minicles, on va faire un shift arbitraire pour chaque subkey suivant ce tableau :
// Tableau des décalages à gauche pour chaque round
static const int SHIFTS[16] = {
	1, 1, 2, 2,
	2, 2, 2, 2,
	1, 2, 2, 2,
	2, 2, 2, 1
};


Et pour chaque Cn et Dn ou n est lindex des shifts, et donc chaque subkey
Mtn il faut les transformer en 48 bits, donc on utilise PC2 qui marche comme PC1 :
static const int PC2[48] = {
	14, 17, 11, 24, 1, 5,
	3, 28, 15, 6, 21, 10,
	23, 19, 12, 4, 26, 8,
	16, 7, 27, 20, 13, 2,
	41, 52, 31, 37, 47, 55,
	30, 40, 51, 45, 33, 48,
	44, 49, 39, 56, 34, 53,
	46, 42, 50, 36, 29, 32
};



Maintenant quon a nos subkeys, on va pouvoir encrypter _cypher avec ls fonction de feistel :

On a 16 rounds et a chaque tour on applique une certaine fonctions :
On applique une certaine fonction sur la moitie droite, puis on la combine avec lautre moitie
Cette famuse fonction prend 2 params : R = moitie droite du bloc, K = subkey[round acutel]

Soit 32 bits et 48 bits

Etapes de f(R, K) :

Expansion               : Etendre R[32] en E[48];   (32 -> 48)
Xor avec la subkey      : E(R) ^ K (48)
Substitution (s-boxes)  : Diviser en 8 blocs de 6 bits -> appliquer 8 S-Boxes -> 4 bits chacun (48 -> 32)
Permutation P			: Rearranger les 32 bits (32)

On va donc utiliser la table E :

static const int E[48] = {
	32, 1,  2,  3,  4,  5,
	4,  5,  6,  7,  8,  9,
	8,  9,  10, 11, 12, 13,
	12, 13, 14, 15, 16, 17,
	16, 17, 18, 19, 20, 21,
	20, 21, 22, 23, 24, 25,
	24, 25, 26, 27, 28, 29,
	28, 29, 30, 31, 32, 1
};

uint64_t expand_r(uint32_t r) {
	uint64_t result = 0;
	for (int i = 0; i < 48; i++) {
		result <<= 1;
		result |= (r >> (32 - E[i])) & 1;
	}
	return result;
}


Puis on xor 
uint64_t xored = expand_r(r) ^ subkey;

Puis les s-boxes :
Entree : 6 bits (0-63)
Sortie : 4 bits (0-15)

On a 8 s-boxes, de S1 a S8, chacune de 4x16 car :

2 bits qui donneront la ligne (0-3)
4 bits pour la colonne (0-15)

Les 2 bits de ligne sont les 2 bits exterieurs et les 4 autres sont ceux interieurs

Ex : 101111
Bit 1 et Bit 6 → 1x1 → ligne = 11 en binaire = 3
Bits 2 à 5 → 0111 → colonne = 7

val = S_BOX[i][3][7]; // i = numéro de la S-box (entre 0 et 7)

CF des_f.c Pour la table des s_box qui sont egalement fournies par openssl

Donc on a  :
uint8_t row = ((block >> 5) << 1) | (block & 1); // bits 1 et 6
uint8_t col = (block >> 1) & 0xF;                // bits 2 à 5
uint8_t value = S_BOX[i][row][col];             // 4 bits de sortie


Après avoir transformé les 48 bits d’entrée en 32 bits via les S-boxes, on applique une permutation fixe appelée P sur ces 32 bits.
Elle a pour but de mélanger les bits de sortie des S-boxes pour augmenter la diffusion du chiffrement.


static const int P[32] = {
	16,  7, 20, 21,
	29, 12, 28, 17,
	1,  15, 23, 26,
	5,  18, 31, 10,
	2,   8, 24, 14,
	32, 27,  3,  9,
	19, 13, 30,  6,
	22, 11,  4, 25
};

Classique permutation

Notre fonction maintenant fini, voici lapplication :
uint32_t new_L = R;
uint32_t new_R = L ^ f_output;

Ensuite pour reorganiser nos swap de L et de R, on les reswap une derniere fois mais cette fois ci sans f(R, K)

On passe enfin a la final permutation notee IP-1 Et qui marhce comme toutes les permutations suivant cette table :
