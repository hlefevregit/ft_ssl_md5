							+-------------------+
							|    Message (M)    |
							+-------------------+
									  |
									  v
							+-------------------+
							|     Padding       |
							|  - ajout de 0x80  |
							|  - puis 0x00s     |
							|  - + taille (64b) |
							+-------------------+
									  |
									  v
					   +-------------------------------+
					   | Découpage en blocs de 512 bits|
					   +-------------------------------+
						 |            |            |
						 v            v            v
				  [Bloc 1]      [Bloc 2]      ... [Bloc N]
						 \            |            /
						  \           |           /
						   v          v          v
			   +------------------------------------------+
			   | Pour chaque bloc :                       |
			   | 1. Initialiser A, B, C, D (valeurs fixes)|
			   | 2. Diviser bloc en 16 mots de 32 bits    |
			   | 3. Appliquer 64 opérations :             |
			   |    - 4 rounds × 16 opérations            |
			   |    - Fonctions F, G, H, I                |
			   |    - Décalages (s)                       |
			   |    - Constantes K[i]                     |
			   | 4. Mettre à jour A, B, C, D              |
			   +------------------------------------------+
									  |
									  v
						 +--------------------------+
						 |   A || B || C || D       |
						 | (en little endian)       |
						 +--------------------------+
									  |
									  v
						 +--------------------------+
						 |     Hash final MD5       |
						 | (128 bits = 32 hexa)     |
						 +--------------------------+




## PADDING

+------------------------------+
|   Message original (M)       |
|    [ "abc", 3 bytes ]        |
+------------------------------+
              |
              v
+--------------------------------------------+
| Ajout d'un bit '1' => 0x80                 |
|  [ 'abc' + 0x80 ]                          |
+--------------------------------------------+
              |
              v
+---------------------------------------------------------+
| Ajout de bits '0' (0x00) pour atteindre :               |
|    - 448 bits (56 bytes) mod 512 (MD5 & SHA-256)        |
| => Longeur totale mod 64 == 56                          |
|  [ 'abc' + 0x80 + 0x00 * N ]                            |
+---------------------------------------------------------+
              |
              v
+---------------------------------------------------------+
| Ajout de la longueur du message initial en **bits**     |
|    - 64 bits pour MD5 et SHA-256                        |
|    - MD5 : encodé en little endian                      |
|    - SHA-256 : encodé en big endian                     |
|  [ total_length (8 bytes) ]                             |
+---------------------------------------------------------+
              |
              v
+---------------------------------------------------------+
| Résultat : message padded de taille multiple de 512 bits|
|  [ bloc de 512 bits (64 bytes), ou + si nécessaire ]    |
+---------------------------------------------------------+

Message long (> 448 bits mod 512)
⟶ Supposons un message de 2001 bits (~250.125 octets)
       ↓

+---------------------------------------------------------------+
| Bloc 1 (512 bits / 64 bytes)                                 |
|  [ Octets 0 à 63 du message original ]                       |
+---------------------------------------------------------------+
                             ↓
+---------------------------------------------------------------+
| Bloc 2                                                        |
|  [ Suite du message original ]                                |
|  [ Puis 0x80 (si encore de la place) ]                        |
|  [ Puis des 0x00… ]                                           |
|  [ Si la taille du message empêche de mettre la taille ici → ]──┐
+---------------------------------------------------------------+ │
                                                                  ↓
+---------------------------------------------------------------+
| Bloc 3 (ajouté uniquement pour stocker la longueur du message)|
|  [ 0x00… ]                                                    |
|  [ Longueur du message sur 64 bits (big- ou little-endian) ]  |
+---------------------------------------------------------------+



## Mise en place de l'algo :

+--------------------------------------------------+
|             Message après padding                |
|      (taille multiple de 512 bits = 64 bytes)    |
+--------------------------------------------------+
             |
             v
+---------------------------------------------------+
|     Découpage en blocs de 512 bits (64 bytes)     |
|  [ Bloc 1 ]  [ Bloc 2 ]  [ Bloc 3 ]  ... [ Bloc N]|
+---------------------------------------------------+
             |
             v
+--------------------------------------------------+
| Pour chaque bloc :                               |
|                                                  |
| 1. Diviser le bloc en 16 mots de 32 bits :       |
|     - M[0] à M[15] pour MD5                      |
|                                                  |
| 3. Initialiser les registres :                   |
|     - MD5 : A, B, C, D (valeurs fixes)           |
+--------------------------------------------------+
             |
             v
+--------------------------------------------------+
|        [ Début des rounds de transformation ]    |
+--------------------------------------------------+



## FONCTIONS

Fonction F:

F(B, C, D) = (B & C) | (~B & D)

 Entrées :     B     C     D
                \   /       \
                 AND         \
                /             \
             (B & C)         (D & ~B)
                \             /
                 \           /
                    OR (|)  
                      ↓
                Résultat : F

+--------+       +--------+
|   B    |------>|        |
|        |       |  AND   |--+
|   C    |-------|        |  |
+--------+       +--------+  |
                             |      +--------+
                             +----->|        |
+--------+      +--------+          |   OR   |--> F
|   B    |--+-->|  NOT   |---+   +->|        |
+--------+      +--------+   |   |  +--------+
                             |   |    
                +--------+   |	 |
     |--------->|  AND   |<--+	 |
     |          |        |		 |
+--------+      +--------+		 |
|   D    |			|			 |
+--------+			+------------+


Fonction G:

G(B, C, D) = (B & D) | (C & ~D)

 Entrées :     B     D     C
                \   /       \
                 AND         \
                /             \
             (B & D)         (C & ~D)
                \             /
                 \           /
                    OR (|)  
                      ↓
                Résultat : G

+--------+       +--------+
|   B    |------>|        |
|        |       |  AND   |--+
|   D    |-------|        |  |
+--------+       +--------+  |
                             |      +--------+
                             +----->|        |
+--------+      +--------+          |   OR   |--> F
|   D    |--+-->|  NOT   |---+   +->|        |
+--------+      +--------+   |   |  +--------+
                             |   |    
                +--------+   |	 |
     |--------->|  AND   |<--+	 |
     |          |        |		 |
+--------+      +--------+		 |
|   C    |			|			 |
+--------+			+------------+

Fonction H:

H(B, C, D) = B ^ C ^ D

Entrées :     B     C     D
                \   |   /
                 \  |  /
                XOR chain
                   ↓
              Résultat : H

+--------+       +--------+
|   B    |------>|        |
+--------+       |        |---+
                 |        |   |
+--------+       |   XOR  |   |
|   C    |------ |        |   |
+--------+       |        |   |
				 +--------+   |
				              |
                              v
                          +--------+
    +-------------------->|  XOR   |--> H
    |                     |        |
+--------+                +--------+
|   D    |
+--------+


Fonction I:

I(B, C, D) =  C ^ (B | ~D)

 Entrées :     B     D     C
                \   /       \
                 OR          |
              (B | ~D)       |
                 \           |
                  \         /
                   XOR --> Résultat : I

+--------+       +--------+
|   D    |--+--->|  NOT   |
+--------+       +--------+  
					  |
                      v             +--------+
+--------+       +--------+         |        |
|   B    |-+---> |   OR   |-------->|  XOR   |--> I
+--------+       |        |         |        |
                 +--------+         +--------+
                                       ^
+--------+                             |
|   C    |-----------------------------+
+--------+



## ITERATIONS

Entrées :
- A, B, C, D     (registres)
- M[g]           (1 mot du bloc)
- K[i]           (constante)
- s[i]           (décalage)
- F(B, C, D)     (fonction logique selon le round)

Étapes :
1. T = A + F(B, C, D) + M[g] + K[i]
2. T = LEFTROTATE(T, s[i])
3. A' = D
   B' = B + T
   C' = B
   D' = C


Où g:

       +-------------------+
       |    i = 0 to 63    | ← Numéro de l’itération
       +-------------------+
                |
                v
   +----------------------------------------+
   | Déterminer le round auquel appartient i|
   +----------------------------------------+
         |          |            |         |
         v          v            +------v  +-------------v
     Round 1        Round 2          Round 3          Round 4
   i ∈ [0,15]     i ∈ [16,31]     i ∈ [32,47]       i ∈ [48,63]
       |               |               +--+              +----------+
       v               v                  v                         v
+------------+ +-----------------+ +-------------------+ +--------------------+
| g[i] = i   | | g[i] = (5×i+1)%16| | g[i] = (3×i+5)%16| | g[i] = (7×i)%16    |
+------------+ +-----------------+ +-------------------+ +--------------------+
      |                  |                   |                     |
      +------------------+-------------------+---------------------+
                               |
                               v
                   +------------------------+
                   | Utiliser M[g[i]] dans  |
                   | l’opération de hashage |
                   +------------------------+

Et s a pour valeur :

static const uint32_t S[64] = {
  // Round 1
   7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,
  // Round 2
   5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,
  // Round 3
   4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,
  // Round 4
   6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21
};

Soit

          +----------+           +---------------------+
   i = →  |  0..15   |  Round 1  | s =  7 12 17 22 ... |
          | 16..31   |  Round 2  | s =  5  9 14 20 ... |
          | 32..47   |  Round 3  | s =  4 11 16 23 ... |
          | 48..63   |  Round 4  | s =  6 10 15 21 ... |
          +----------+           +---------------------+




## RESULTAT FINAL

On addition nos registres modifés à nos constantes de départ :

A += AA;
B += BB;
C += CC;
D += DD;

Puis on concatene:
Digest = A || B || C || D   ← Concaténés (little endian)


On a notre resultat de 32bits hashé